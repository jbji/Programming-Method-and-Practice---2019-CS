
bool 深度优先搜索(当前位置){
	if(当前位置是零){
		for(枚举地图至ii,jj位置){
			if(ii,jj的地图位置,没越界，也没有被访问过，也大于零){
				return 深度优先搜索(ii,jj位置);
			}
		}
	}
	if(可访问块的数量 == 0) {
		return 等待匹配块的数量 == 0; //完全匹配情况的剪枝
	}
	int 枚举失败数量;
	for(从当前位置开始，枚举四个方向的下一位置){
		if(下一位置没越界 && 下一位置没访问过 && 下一位置大于零){
			if(下一位置和当前位置是不同类型的){//特殊情况，需要交换啦
				//交换两个块，看看会发生什么。
				交换两个块;
				标记交换情况;//注意，交换可能层叠
				int a = 连通数量(当前位置);
				int b = 连通数量(下一位置);
				if(a>=3){
					连通块标记(当前位置,访问过);
					等待匹配块的数量 -= a;}
				if(b>=3){
					连通块标记(下一位置,访问过);
					等待匹配块的数量 -= b;}
				if(a>=3 || b>=3) {
					标记(当前位置,访问过);
					if (深度优先搜索(下一位置)) return true;
					标记(当前位置,未访问过);}
				if(a>=3){
					连通块标记(当前位置,未访问过);
					等待匹配块的数量 += a;}
				if(b>=3){
					连通块标记(下一位置,未访问过);
					等待匹配块的数量 += b;}
				取消交换情形标记;
				取消交换两个块;
			}
			//对所有情形一视同仁的往下一步继续搜索
			标记(当前位置,访问过);
			if(深度优先搜索(下一位置)) return true;
			标记(当前位置,未访问过);
		}else{
			枚举失败数量++;
		}
	}
	if(枚举失败数量==2 && 还有等待匹配的块){
		for(枚举地图至ii,jj位置){
			if(ii,jj的地图位置,没越界，也没有被访问过，也不是零){
				标记(当前位置,访问过);
				if(深度优先搜索(ii,jj位置)) return true;
				标记(当前位置,未访问过);
				return false;
			}
		}
	}
	return false;
}

int 连通数量(某一位置){
	int 比较源 = 地图[某一位置];
	int 可连通数量 = 0;
	//让我们来做一个简单的bfs，看一看有多少个可连通块吧
	队列<坐标> q;
	q.push(某一位置);
	while(q非空){
		坐标 临时坐标 = q.front();
		可连通数量 ++;
		q.pop();
		for(从临时坐标开始，枚举四个方向的下一位置){
			if(下一位置没越界 && 下一位置和比较源是相同的 && 下一位置也没有被访问过){
				q.push(下一位置坐标);
			}
		}
	}
	return 可连通数量;
}

void 连通块标记(某一位置){
	int 比较源 = 地图[某一位置]; //因为涉及到修改"某一位置"，所以必须先行将其存入缓存
	队列<坐标> q;
	q.push(某一位置);
	while(q非空){
		坐标 临时坐标 = q.front();
		标记(临时坐标，tmp>0); //小于零表示访问过，访问过的非，即大于零
		地图[临时坐标] = -地图[临时坐标]; //正负号倒置;
		q.pop();
		for(从临时坐标开始，枚举四个方向的下一位置){
			if(下一位置没越界 && 下一位置和比较源是相同的 && 下一位置也没有被访问过){
				q.push(下一位置坐标);
			}
		}
	}
}


void 标记(位置,bool 是否访问过){
	if(当前位置布尔值和新的布尔值是不同的){
		标记数组[位置] = 是否访问过;
		if(现在的访问状态){
			可访问块的数量减少;
		}else{
			可访问块的数量增加;
		}
	}
}