bool 深度优先搜索(){
	for(枚举地图至ii,jj位置){
		if(ii,jj地图位置是孤立块){
			return false;
		}
		if(ii,jj的地图位置大于零){
			for(从当前位置开始，枚举右和下两个方向的下一位置){
				if(下一位置没越界 && 下一位置大于零 && 下一位置和当前位置是不同类型的){//特殊情况，需要交换啦
					//交换两个块，看看会发生什么。
					交换两个块;
					*标记交换情况;
					int a = 连通数量(当前位置);
					int b = 连通数量(下一位置);
					if(a>=3){
						连通块标记(当前位置,访问过);
						等待匹配块的数量 -= a;
					}
					if(b>=3){
						连通块标记(下一位置,访问过);
						等待匹配块的数量 -= b;
					}
					if(a>=3 || b>=3) {
						if (深度优先搜索(下一位置)) return true;
					}
					if(a>=3){
						连通块标记(当前位置,未访问过);
						等待匹配块的数量 += a;
					}
					if(b>=3){
						连通块标记(下一位置,未访问过);
						等待匹配块的数量 += b;
					}
					*取消交换情形标记;
					取消交换两个块;
				}
			}
		}
	}
	return 等待匹配块的数量 == 0;
}

int 连通数量(某一位置){
	int 比较源 = 地图[某一位置];
	int 可连通数量 = 0;
	//让我们来做一个简单的bfs，看一看有多少个可连通块吧
	队列<坐标> q;
	q.push(某一位置);
	while(q非空){
		坐标 临时坐标 = q.front();
		可连通数量 ++;
		q.pop();
		for(从临时坐标开始，枚举四个方向的下一位置){
			if(下一位置没越界 && 下一位置和比较源是相同的 && 下一位置也没有被访问过){
				q.push(下一位置坐标);
			}
		}
	}
	return 可连通数量;
}

void 连通块标记(某一位置){
	int 比较源 = 地图[某一位置]; //因为涉及到修改"某一位置"，所以必须先行将其存入缓存
	队列<坐标> q;
	q.push(某一位置);
	while(q非空){
		坐标 临时坐标 = q.front();
		*将临时坐标位置标记为消去;
		q.pop();
		for(从临时坐标开始，枚举四个方向的下一位置){
			if(下一位置没越界 && 下一位置和比较源是相同的 && 下一位置也没有被访问过){
				q.push(下一位置坐标);
			}
		}
	}
}